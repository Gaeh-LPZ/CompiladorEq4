/* parser.cup - Versión compatible sin conflictos */
import java_cup.runtime.*;
import java.util.*;
import java.io.*;

/* Código de acciones */
action code {:
    public static PrintWriter archivoTraduccion;
    public static StringBuilder codigoTraducido = new StringBuilder();
    private static HashMap<String, String> tablaSemantica = new HashMap<>();
    private static List<String> erroresSemanticos = new ArrayList<>();

    // --- CLASE AUXILIAR NUEVA PARA MANEJAR LISTAS DE VARIABLES ---
    static class VarInfo {
        String name;
        String value; // null si no tiene asignación
        public VarInfo(String n, String v) { this.name = n; this.value = v; }
    }
    // -------------------------------------------------------------
    
    public static void iniciarTraduccion(String nombreArchivo) {
        try {
            archivoTraduccion = new PrintWriter(new FileWriter(nombreArchivo));
            codigoTraducido = new StringBuilder();
            codigoTraducido.append("#include <iostream>\n#include <string>\nusing namespace std;\n\n");
        } catch (IOException e) { 
            System.err.println("Error al iniciar traducción: " + e.getMessage());
        }
    }
    
    public static void escribir(String codigo) {
        if (codigoTraducido == null) codigoTraducido = new StringBuilder();
        codigoTraducido.append(codigo);
        if (archivoTraduccion != null) {
            archivoTraduccion.print(codigo);
            archivoTraduccion.flush();
        }
    }
    
    public static void finalizarTraduccion() {
        if (archivoTraduccion != null) archivoTraduccion.close();
    }
    
    public static void declararVariable(String nombre, String tipo) {
        tablaSemantica.put(nombre, tipo);
    }
    
    public static List<String> getErroresSemanticos() {
        return erroresSemanticos;
    }
    
    public static String traducirTipo(String t) {
        return t.equals("String") ? "string" : t.equals("boolean") ? "bool" : t;
    }
    
    public static StringBuilder getCodigoTraducido() {
        return codigoTraducido;
    }
:}

/* Código del parser */
parser code {:
    public void report_error(String message, Object info) {
        System.err.println("Error: " + message);
    }
    
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.err.println("Análisis abortado");
    }
:}

/* Inicialización */
init with {: 
    action_obj.iniciarTraduccion("salida/traduccion.cpp"); 
:};

scan with {: return getScanner().next_token(); :};

/* Terminales */
terminal PUBLIC, CLASS, STATIC, VOID, MAIN, PRIVATE, PROTECTED;
terminal EXTENDS, IMPLEMENTS, NEW;
terminal INT, FLOAT, BOOLEAN, STRING;
terminal IF, ELSE, FOR, WHILE, DO, SWITCH, CASE, DEFAULT, BREAK;
terminal SYSTEM, OUT, PRINTLN, PACKAGE, IMPORT, RETURN;
terminal SUMA, RESTA, MULTIPLICACION, DIVISION, MODULO;
terminal ASIGNACION, ASIG_SUMA, ASIG_RESTA, ASIG_MULT, ASIG_DIV;
terminal INCREMENTO, DECREMENTO;
terminal AND, OR, NOT;
terminal MENOR_QUE, MAYOR_QUE, IGUAL_IGUAL, DIFERENTE;
terminal MENOR_IGUAL, MAYOR_IGUAL;
terminal LLAVE_IZQ, LLAVE_DER, PARENTESIS_IZQ, PARENTESIS_DER;
terminal CORCHETE_IZQ, CORCHETE_DER;
terminal PUNTO_COMA, PUNTO, COMA, DOS_PUNTOS;
terminal String IDENTIFICADOR;
terminal Integer NUMERO_ENTERO;
terminal Float NUMERO_FLOTANTE;
terminal String LITERAL;

/* Non-terminals */
non terminal programa, pkg_opt, imp_list, imp_decl, clase;
non terminal herencia_opt, implementa_opt;
non terminal miembros, miembro;
non terminal metodo, main_m, constructor;
non terminal params;
non terminal bloque, sents_opt, sents, sent;
non terminal decl_miembro, decl_local, asig, inc_dec;
non terminal ctrl, if_s, else_opt, for_s, while_s, do_while_s, switch_s;
non terminal cases, case_s, def_opt, ret, call;
non terminal String tipo, expr, term, fact, cond, relacional, logica, arg_single, arg_concat;
non terminal List<VarInfo> lista_vars;
non terminal VarInfo var_part;
non terminal String nombre_completo;

/* Precedencias */
precedence left OR;
precedence left AND;
precedence nonassoc IGUAL_IGUAL, DIFERENTE, MENOR_QUE, MAYOR_QUE;
precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION, MODULO;
precedence nonassoc MENOR_IGUAL, MAYOR_IGUAL;

start with programa;

programa ::= pkg_opt imp_list clase {: action_obj.finalizarTraduccion(); :} ;

pkg_opt ::= PACKAGE nombre_completo PUNTO_COMA
    | /* empty */ ;

imp_list ::= imp_list imp_decl 
    | /* empty */ ;

imp_decl ::= IMPORT nombre_completo PUNTO_COMA
    | IMPORT nombre_completo PUNTO MULTIPLICACION PUNTO_COMA ;

clase ::= PUBLIC CLASS IDENTIFICADOR:n herencia_opt implementa_opt LLAVE_IZQ
    {: action_obj.escribir("// Clase " + n + "\n\n"); :}
    miembros LLAVE_DER ;

herencia_opt ::= EXTENDS IDENTIFICADOR | /* empty */ ;

nombre_completo ::= IDENTIFICADOR:id
    {: RESULT = id; :}
    | nombre_completo:p PUNTO IDENTIFICADOR:id
    {: RESULT = p + "." + id; :};

implementa_opt ::= IMPLEMENTS IDENTIFICADOR | /* empty */ ;

miembros ::= miembro miembros | /* empty */ ;

miembro ::= decl_miembro 
    | constructor 
    | metodo 
    | main_m ;

/* Declaración de variables miembro (con modificadores) */
decl_miembro ::= PRIVATE tipo:t IDENTIFICADOR:n PUNTO_COMA
    {: action_obj.declararVariable(n, t);
       action_obj.escribir("    " + action_obj.traducirTipo(t) + " " + n + ";\n"); :}
    | PRIVATE tipo:t IDENTIFICADOR:n ASIGNACION expr:e PUNTO_COMA
    {: action_obj.declararVariable(n, t);
       action_obj.escribir("    " + action_obj.traducirTipo(t) + " " + n + " = " + e + ";\n\n"); :}
    | PUBLIC tipo:t IDENTIFICADOR:n PUNTO_COMA
    {: action_obj.declararVariable(n, t);
       action_obj.escribir("    " + action_obj.traducirTipo(t) + " " + n + ";\n"); :}
    | PUBLIC tipo:t IDENTIFICADOR:n ASIGNACION expr:e PUNTO_COMA
    {: action_obj.declararVariable(n, t);
       action_obj.escribir("    " + action_obj.traducirTipo(t) + " " + n + " = " + e + ";\n\n"); :}
    | PROTECTED tipo:t IDENTIFICADOR:n PUNTO_COMA
    {: action_obj.declararVariable(n, t);
       action_obj.escribir("    " + action_obj.traducirTipo(t) + " " + n + ";\n"); :}
    | PROTECTED tipo:t IDENTIFICADOR:n ASIGNACION expr:e PUNTO_COMA
    {: action_obj.declararVariable(n, t);
       action_obj.escribir("    " + action_obj.traducirTipo(t) + " " + n + " = " + e + ";\n\n"); :} ;

/* Constructor */
constructor ::= PUBLIC IDENTIFICADOR:n PARENTESIS_IZQ PARENTESIS_DER
    {: action_obj.escribir("// Constructor " + n + "\nvoid init_" + n + "() {\n"); :}
    bloque
    {: action_obj.escribir("}\n\n"); :}
    | PUBLIC IDENTIFICADOR:n PARENTESIS_IZQ params PARENTESIS_DER
    {: action_obj.escribir("// Constructor " + n + "\nvoid init_" + n + "() {\n"); :}
    bloque
    {: action_obj.escribir("}\n\n"); :} ;

/* Métodos */
metodo ::= PUBLIC VOID IDENTIFICADOR:n PARENTESIS_IZQ PARENTESIS_DER
    {: action_obj.escribir("void " + n + "() {\n"); :}
    bloque
    {: action_obj.escribir("}\n\n"); :}
    | PUBLIC VOID IDENTIFICADOR:n PARENTESIS_IZQ params PARENTESIS_DER
    {: action_obj.escribir("void " + n + "(/* params */) {\n"); :}
    bloque
    {: action_obj.escribir("}\n\n"); :}
    | PUBLIC tipo:t IDENTIFICADOR:n PARENTESIS_IZQ PARENTESIS_DER
    {: action_obj.escribir(action_obj.traducirTipo(t) + " " + n + "() {\n"); :}
    bloque
    {: action_obj.escribir("}\n\n"); :}
    | PUBLIC tipo:t IDENTIFICADOR:n PARENTESIS_IZQ params PARENTESIS_DER
    {: action_obj.escribir(action_obj.traducirTipo(t) + " " + n + "(/* params */) {\n"); :}
    bloque
    {: action_obj.escribir("}\n\n"); :}
    | PRIVATE VOID IDENTIFICADOR:n PARENTESIS_IZQ PARENTESIS_DER
    {: action_obj.escribir("void " + n + "() {\n"); :}
    bloque
    {: action_obj.escribir("}\n\n"); :}
    | PRIVATE VOID IDENTIFICADOR:n PARENTESIS_IZQ params PARENTESIS_DER
    {: action_obj.escribir("void " + n + "(/* params */) {\n"); :}
    bloque
    {: action_obj.escribir("}\n\n"); :}
    | PROTECTED VOID IDENTIFICADOR:n PARENTESIS_IZQ PARENTESIS_DER
    {: action_obj.escribir("void " + n + "() {\n"); :}
    bloque
    {: action_obj.escribir("}\n\n"); :}
    | PROTECTED VOID IDENTIFICADOR:n PARENTESIS_IZQ params PARENTESIS_DER
    {: action_obj.escribir("void " + n + "(/* params */) {\n"); :}
    bloque
    {: action_obj.escribir("}\n\n"); :} ;

params ::= tipo IDENTIFICADOR
    | tipo IDENTIFICADOR COMA params ;

main_m ::= PUBLIC STATIC VOID MAIN PARENTESIS_IZQ STRING CORCHETE_IZQ CORCHETE_DER IDENTIFICADOR PARENTESIS_DER
    {: action_obj.escribir("int main(int argc, char *argv[]) {\n"); :}
    bloque
    {: action_obj.escribir("    return 0;\n}\n"); :} ;

bloque ::= LLAVE_IZQ sents_opt LLAVE_DER ;

sents_opt ::= sents | /* empty */ ;

sents ::= sent sents | sent ;

sent ::= decl_local | asig | inc_dec | ctrl | call PUNTO_COMA | ret | bloque | expr PUNTO_COMA 
      | BREAK PUNTO_COMA {: action_obj.escribir("    break;\n"); :} ;

/* Declaraciones locales GENERALES (recursivas) */
decl_local ::= tipo:t lista_vars:l PUNTO_COMA
    {: 
        // Recorremos la lista de variables detectadas
        for(VarInfo v : l) {
            // 1. Semántica: Registrar en tabla de símbolos
            action_obj.declararVariable(v.name, t);
            
            // 2. Traducción: Generar código C++
            String tipoTraducido = action_obj.traducirTipo(t);
            if(v.value == null) {
                // Caso: int a;
                action_obj.escribir("    " + tipoTraducido + " " + v.name + ";\n");
            } else {
                // Caso: int a = 5;
                action_obj.escribir("    " + tipoTraducido + " " + v.name + " = " + v.value + ";\n");
            }
        }
    :} 
    | tipo CORCHETE_IZQ CORCHETE_DER IDENTIFICADOR:n PUNTO_COMA
    {: action_obj.escribir("    // array: " + n + " (Pendiente de implementar traducción)\n"); :} 
    ;

/* Reglas recursivas para lista de variables (ej: a, b=1, c) */
lista_vars ::= var_part:v
    {: 
        List<VarInfo> l = new ArrayList<>(); 
        l.add(v); 
        RESULT = l; 
    :}
    | lista_vars:l COMA var_part:v
    {: 
        l.add(v); 
        RESULT = l; 
    :};

/* Una variable individual (con o sin valor) */
var_part ::= IDENTIFICADOR:n
    {: RESULT = new VarInfo(n, null); :}
    | IDENTIFICADOR:n ASIGNACION expr:e
    {: RESULT = new VarInfo(n, e); :};

tipo ::= INT {: RESULT = "int"; :}
    | FLOAT {: RESULT = "float"; :}
    | BOOLEAN {: RESULT = "boolean"; :}
    | STRING {: RESULT = "String"; :}
    | IDENTIFICADOR:n {: RESULT = n; :} ;

asig ::= IDENTIFICADOR:n ASIGNACION expr:e PUNTO_COMA
    {: action_obj.escribir("    " + n + " = " + e + ";\n"); :}
    | IDENTIFICADOR:n ASIG_SUMA expr:e PUNTO_COMA
    {: action_obj.escribir("    " + n + " += " + e + ";\n"); :}
    | IDENTIFICADOR:n ASIG_RESTA expr:e PUNTO_COMA
    {: action_obj.escribir("    " + n + " -= " + e + ";\n"); :}
    | IDENTIFICADOR:n ASIG_MULT expr:e PUNTO_COMA
    {: action_obj.escribir("    " + n + " *= " + e + ";\n"); :}
    | IDENTIFICADOR:n ASIG_DIV expr:e PUNTO_COMA
    {: action_obj.escribir("    " + n + " /= " + e + ";\n"); :} ;

inc_dec ::= IDENTIFICADOR:n INCREMENTO PUNTO_COMA
    {: action_obj.escribir("    " + n + "++;\n"); :}
    | IDENTIFICADOR:n DECREMENTO PUNTO_COMA
    {: action_obj.escribir("    " + n + "--;\n"); :} ;

ctrl ::= if_s | for_s | while_s | do_while_s | switch_s ;

if_s ::= IF PARENTESIS_IZQ cond:c PARENTESIS_DER
    {: action_obj.escribir("    if (" + c + ") {\n"); :}
    bloque
    {: action_obj.escribir("    }\n"); :}
    else_opt ;

else_opt ::= ELSE 
    {: action_obj.escribir("    else {\n"); :} 
    bloque 
    {: action_obj.escribir("    }\n"); :}
    | /* empty */ ;

for_s ::= 
    /* 1. Caso simple con incremento: for(i=0; i<10; i++) */
    FOR PARENTESIS_IZQ IDENTIFICADOR:v ASIGNACION expr:e PUNTO_COMA cond:c PUNTO_COMA IDENTIFICADOR:v2 INCREMENTO PARENTESIS_DER
    {: action_obj.escribir("    for (" + v + " = " + e + "; " + c + "; " + v2 + "++) {\n"); :}
    bloque {: action_obj.escribir("    }\n"); :}

    /* 2. Caso simple con decremento: for(i=10; i>0; i--) */
    | FOR PARENTESIS_IZQ IDENTIFICADOR:v ASIGNACION expr:e PUNTO_COMA cond:c PUNTO_COMA IDENTIFICADOR:v2 DECREMENTO PARENTESIS_DER
    {: action_obj.escribir("    for (" + v + " = " + e + "; " + c + "; " + v2 + "--) {\n"); :}
    bloque {: action_obj.escribir("    }\n"); :}

    /* 3. Caso declarando variable con incremento: for(int i=0; i<10; i++) */
    | FOR PARENTESIS_IZQ tipo:t IDENTIFICADOR:v ASIGNACION expr:e PUNTO_COMA cond:c PUNTO_COMA IDENTIFICADOR:v2 INCREMENTO PARENTESIS_DER
    {: action_obj.declararVariable(v, t);
       action_obj.escribir("    for (" + t + " " + v + " = " + e + "; " + c + "; " + v2 + "++) {\n"); :}
    bloque {: action_obj.escribir("    }\n"); :}

    /* 4. Caso declarando variable con decremento: for(int i=10; i>0; i--) */
    | FOR PARENTESIS_IZQ tipo:t IDENTIFICADOR:v ASIGNACION expr:e PUNTO_COMA cond:c PUNTO_COMA IDENTIFICADOR:v2 DECREMENTO PARENTESIS_DER
    {: action_obj.declararVariable(v, t);
       action_obj.escribir("    for (" + t + " " + v + " = " + e + "; " + c + "; " + v2 + "--) {\n"); :}
    bloque {: action_obj.escribir("    }\n"); :}

    /* 5. Caso con EXPRESIÓN GENERAL (CORREGIDO): for(i=0; i<10; i+1) */
    /* Se agregó ':ex' para capturar el valor y se usa '+ ex +' en el print */
    | FOR PARENTESIS_IZQ IDENTIFICADOR:v ASIGNACION expr:e PUNTO_COMA cond:c PUNTO_COMA expr:ex PARENTESIS_DER
    {: action_obj.escribir("    for (" + v + " = " + e + "; " + c + "; " + ex + ") {\n"); :}
    bloque {: action_obj.escribir("    }\n"); :}

    /* 6. Caso declarando variable con EXPRESIÓN GENERAL (CORREGIDO) */
    | FOR PARENTESIS_IZQ tipo:t IDENTIFICADOR:v ASIGNACION expr:e PUNTO_COMA cond:c PUNTO_COMA expr:ex PARENTESIS_DER
    {: action_obj.declararVariable(v, t);
       action_obj.escribir("    for (" + t + " " + v + " = " + e + "; " + c + "; " + ex + ") {\n"); :}
    bloque {: action_obj.escribir("    }\n"); :} 
    ;

while_s ::= WHILE PARENTESIS_IZQ cond:c PARENTESIS_DER
    {: action_obj.escribir("    while (" + c + ") {\n"); :}
    bloque {: action_obj.escribir("    }\n"); :} ;

do_while_s ::= DO {: action_obj.escribir("    do {\n"); :}
    bloque WHILE PARENTESIS_IZQ cond:c PARENTESIS_DER PUNTO_COMA
    {: action_obj.escribir("    } while (" + c + ");\n"); :} ;

switch_s ::= SWITCH PARENTESIS_IZQ IDENTIFICADOR:v PARENTESIS_DER LLAVE_IZQ
    {: action_obj.escribir("    switch (" + v + ") {\n"); :}
    cases def_opt LLAVE_DER
    {: action_obj.escribir("    }\n"); :} ;

cases ::= case_s cases | case_s ;

case_s ::= CASE NUMERO_ENTERO:n DOS_PUNTOS
    {: action_obj.escribir("        case " + n + ":\n"); :}
    sents_opt 
    /* Ya no forzamos BREAK aquí. Si el usuario lo pone, 
       se procesará gracias a la regla nueva en 'sent' */
    ;

def_opt ::= DEFAULT DOS_PUNTOS
    {: action_obj.escribir("        default:\n"); :}
    sents_opt | /* empty */ ;

ret ::= RETURN expr:e PUNTO_COMA
    {: action_obj.escribir("    return " + e + ";\n"); :} ;

call ::= SYSTEM PUNTO OUT PUNTO PRINTLN PARENTESIS_IZQ arg_concat:a PARENTESIS_DER
    {: action_obj.escribir("    cout << " + a + " << endl;\n"); :}
    | SYSTEM PUNTO OUT PUNTO PRINTLN PARENTESIS_IZQ arg_single:a PARENTESIS_DER
    {: action_obj.escribir("    cout << " + a + " << endl;\n"); :}
    | IDENTIFICADOR:n PARENTESIS_IZQ PARENTESIS_DER
    {: action_obj.escribir("    " + n + "();\n"); :} ;

arg_single ::= expr:e {: RESULT = e; :};

arg_concat ::= arg_single:a1 SUMA arg_single:a2 {: RESULT = a1 + " << \" \" << " + a2; :}
    | arg_concat:ac SUMA arg_single:a {: RESULT = ac + " << \" \" << " + a; :} ;

cond ::= relacional:r {: RESULT = r; :}
    | logica:l {: RESULT = l; :}
    | IDENTIFICADOR:n {: RESULT = n; :} ;

relacional ::= expr:e1 MENOR_QUE expr:e2 {: RESULT = e1 + " < " + e2; :}
    | expr:e1 MAYOR_QUE expr:e2 {: RESULT = e1 + " > " + e2; :}
    | expr:e1 IGUAL_IGUAL expr:e2 {: RESULT = e1 + " == " + e2; :}
    | expr:e1 DIFERENTE expr:e2 {: RESULT = e1 + " != " + e2; :}
    /* --- NUEVAS REGLAS --- */
    | expr:e1 MENOR_IGUAL expr:e2 {: RESULT = e1 + " <= " + e2; :}
    | expr:e1 MAYOR_IGUAL expr:e2 {: RESULT = e1 + " >= " + e2; :} ;

logica ::= relacional:r1 AND relacional:r2 {: RESULT = r1 + " && " + r2; :}
    | relacional:r1 OR relacional:r2 {: RESULT = r1 + " || " + r2; :}
    | IDENTIFICADOR:n1 AND IDENTIFICADOR:n2 {: RESULT = n1 + " && " + n2; :}
    | IDENTIFICADOR:n1 OR IDENTIFICADOR:n2 {: RESULT = n1 + " || " + n2; :}
    | relacional:r AND IDENTIFICADOR:n {: RESULT = r + " && " + n; :}
    | IDENTIFICADOR:n AND relacional:r {: RESULT = n + " && " + r; :}
    | relacional:r OR IDENTIFICADOR:n {: RESULT = r + " || " + n; :}
    | IDENTIFICADOR:n OR relacional:r {: RESULT = n + " || " + r; :} 
    ;

expr ::= term:t {: RESULT = t; :}
    | expr:e SUMA term:t {: RESULT = e + " + " + t; :}
    | expr:e RESTA term:t {: RESULT = e + " - " + t; :} ;

term ::= fact:f {: RESULT = f; :}
    | term:t MULTIPLICACION fact:f {: RESULT = t + " * " + f; :}
    | term:t DIVISION fact:f {: RESULT = t + " / " + f; :}
    | term:t MODULO fact:f {: RESULT = t + " % " + f; :} ;

fact ::= NUMERO_ENTERO:n {: RESULT = n.toString(); :}
    | NUMERO_FLOTANTE:n {: RESULT = n.toString(); :}
    | IDENTIFICADOR:n {: RESULT = n; :}
    | LITERAL:l {: RESULT = l; :}  /* <--- NUEVO: Permite strings en expresiones */
    | PARENTESIS_IZQ expr:e PARENTESIS_DER {: RESULT = "(" + e + ")"; :} ;